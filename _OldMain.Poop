import Foundation

import SwiftyGPIO

#if os(Linux)
    import Glibc
#else
    import Darwin.C
#endif
import Foundation

//var serial = SerialController()


///Setup Code
public var writeBuffer = ""
//Start a thread for the castle. This is what manages all of the pins

/*
 var pingTime = Date().timeIntervalSinceReferenceDate
 func ping () {
 //    serial.send(string: "0\n")
 }
 
 
 let pingThread = Thread(){
 while true {
 if Date().timeIntervalSinceReferenceDate - pingTime > 1 {
 ping()
 pingTime = Date().timeIntervalSinceReferenceDate
 print("pinged")
 }
 }
 }
 
 
 serial.receiveThread = Thread(){
 while true {
 
 
 do {
 let receivedString = try serial.serialPort.readString(ofLength: 1)
 
 //                    serialDelegate.receiveData(data: receivedString)
 
 
 
 serial.receivedData = [receivedString]
 DispatchQueue.main.async {
 print(":" + receivedString, terminator: ":")
 
 }
 } catch {
 //                    print("noRead!")
 }
 }
 }
 pingThread.start()
 serial.receiveThread.start()
 */

//let period = 1_900_000
//let pwms = SwiftyGPIO.hardwarePWMs(for:.RaspberryPiPlusZero)!
//let pwm = (pwms[0]?[.P18])!
//pwm.initPWM()

let uarts = SwiftyGPIO.UARTs(for:.RaspberryPiPlusZero)!
var uart = uarts[0]
uart.configureInterface(speed: .S2400, bitsPerChar: .Eight, stopBits: .One, parity: .None)


//print("PWM from GPIO18 with 500ns period and 50% duty cycle")
//100
//pwm.startPWM(period: period, duty: 0)
//        let throttle = Float(input ?? "0.0") ?? 0.0
//        pwm.startPWM(period: period, duty: throttle)
//        print(throttle)


//RADIO


print("Ready...")

let tRead = Thread(){
    while true {
        let s = uart.readLine()
        print("Echo: "+s, terminator: "")
    }
}
tRead.start()

var exit = false

while(!exit){
    
    print("Send: ", terminator:" ")
    var input = readLine(strippingNewline: true)
    exit = (input=="x") ? true : false
    
    if !exit {
        uart.writeString(input!)
    }
}
